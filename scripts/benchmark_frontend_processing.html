<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Frontend Processing Benchmark</title>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.8/dist/purify.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1200px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .benchmark-card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 { color: #333; }
    h2 { color: #666; font-size: 18px; margin-top: 0; }
    .result {
      font-family: monospace;
      padding: 10px;
      background: #f0f0f0;
      border-radius: 4px;
      margin: 10px 0;
    }
    .timing { color: #2563eb; font-weight: bold; }
    .error { color: #dc2626; }
    button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover { background: #1d4ed8; }
    button:disabled { background: #9ca3af; cursor: not-allowed; }
    #output { white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>üìä Frontend Legislation Processing Benchmark</h1>

  <div class="benchmark-card">
    <h2>Test: Fetch ‚Üí Sanitize ‚Üí Render Pipeline</h2>
    <button id="runBenchmark" onclick="runBenchmark()">Run Benchmark</button>
    <div id="output"></div>
  </div>

  <div class="benchmark-card">
    <h2>Rendered Content Preview</h2>
    <div id="preview" style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 10px;"></div>
  </div>

  <script>
    const TEST_CASES = [
      { path: 'ukpga/2024/9/data.html', name: 'Arbitration Act 2024 (303 KB)' },
      { path: 'ukpga/1998/42/data.html', name: 'Human Rights Act 1998 (230 KB)' },
      { path: 'ukpga/2020/1/data.html', name: 'European Union Act 2020 (666 KB)' },
      { path: 'ukpga/2018/12/data.html', name: 'Data Protection Act 2018 (3592 KB)' },
    ];

    async function benchmarkSingleDocument(path, name) {
      const output = document.getElementById('output');
      output.innerHTML += `\nüìÑ ${name}\n`;
      output.innerHTML += `   Path: ${path}\n`;
      output.innerHTML += `${'='.repeat(80)}\n`;

      try {
        // Step 1: Fetch from proxy
        const fetchStart = performance.now();
        const response = await fetch(`http://localhost:8000/legislation/proxy/${path}`);
        const fetchEnd = performance.now();
        const fetchTime = fetchEnd - fetchStart;
        output.innerHTML += `   ‚úÖ FETCH:        <span class="timing">${fetchTime.toFixed(0)}ms</span>\n`;

        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        // Step 2: Get text
        const textStart = performance.now();
        const html = await response.text();
        const textEnd = performance.now();
        const textTime = textEnd - textStart;
        output.innerHTML += `   ‚úÖ GET TEXT:     <span class="timing">${textTime.toFixed(0)}ms</span>\n`;

        const sizeKB = (html.length / 1024).toFixed(1);
        output.innerHTML += `   üìè SIZE:         ${sizeKB} KB (${html.length.toLocaleString()} chars)\n`;

        // Step 3: Fix image URLs
        const replaceStart = performance.now();
        const fixedHtml = html.replace(/src="\/images\//g, 'src="https://www.legislation.gov.uk/images/');
        const replaceEnd = performance.now();
        const replaceTime = replaceEnd - replaceStart;
        output.innerHTML += `   ‚úÖ FIX IMAGES:   <span class="timing">${replaceTime.toFixed(0)}ms</span>\n`;

        // Step 4: DOMPurify sanitize
        const sanitizeStart = performance.now();
        const clean = DOMPurify.sanitize(fixedHtml, {
          ADD_TAGS: ['img'],
          ADD_ATTR: ['src', 'alt', 'width', 'height', 'class']
        });
        const sanitizeEnd = performance.now();
        const sanitizeTime = sanitizeEnd - sanitizeStart;
        output.innerHTML += `   ‚úÖ SANITIZE:     <span class="timing">${sanitizeTime.toFixed(0)}ms</span>\n`;

        // Step 5: DOM insertion
        const preview = document.getElementById('preview');
        const insertStart = performance.now();
        preview.innerHTML = clean;
        const insertEnd = performance.now();
        const insertTime = insertEnd - insertStart;
        output.innerHTML += `   ‚úÖ DOM INSERT:   <span class="timing">${insertTime.toFixed(0)}ms</span>\n`;

        // Step 6: Force reflow/render
        const renderStart = performance.now();
        const height = preview.offsetHeight; // Force reflow
        const renderEnd = performance.now();
        const renderTime = renderEnd - renderStart;
        output.innerHTML += `   ‚úÖ RENDER:       <span class="timing">${renderTime.toFixed(0)}ms</span>\n`;

        // Total time
        const totalTime = fetchTime + textTime + replaceTime + sanitizeTime + insertTime + renderTime;
        output.innerHTML += `   ‚è±Ô∏è  TOTAL:        <span class="timing">${totalTime.toFixed(0)}ms</span>\n`;

        // Breakdown
        const breakdown = [
          { name: 'Network (fetch + text)', time: fetchTime + textTime, pct: ((fetchTime + textTime) / totalTime * 100).toFixed(1) },
          { name: 'Image URL replace', time: replaceTime, pct: (replaceTime / totalTime * 100).toFixed(1) },
          { name: 'DOMPurify sanitize', time: sanitizeTime, pct: (sanitizeTime / totalTime * 100).toFixed(1) },
          { name: 'DOM insertion', time: insertTime, pct: (insertTime / totalTime * 100).toFixed(1) },
          { name: 'Browser render', time: renderTime, pct: (renderTime / totalTime * 100).toFixed(1) }
        ];

        output.innerHTML += `\n   üìä BREAKDOWN:\n`;
        breakdown.forEach(b => {
          output.innerHTML += `      ${b.name.padEnd(25)} ${b.time.toFixed(0).padStart(6)}ms (${b.pct.padStart(5)}%)\n`;
        });

        output.innerHTML += `\n`;

        return {
          name,
          path,
          sizeKB: parseFloat(sizeKB),
          timings: {
            fetch: fetchTime,
            text: textTime,
            replace: replaceTime,
            sanitize: sanitizeTime,
            insert: insertTime,
            render: renderTime,
            total: totalTime
          }
        };

      } catch (error) {
        output.innerHTML += `   <span class="error">‚ùå ERROR: ${error.message}</span>\n\n`;
        return null;
      }
    }

    async function runBenchmark() {
      const button = document.getElementById('runBenchmark');
      const output = document.getElementById('output');

      button.disabled = true;
      output.innerHTML = 'üöÄ Starting benchmark...\n\n';

      const results = [];

      for (const testCase of TEST_CASES) {
        const result = await benchmarkSingleDocument(testCase.path, testCase.name);
        if (result) results.push(result);

        // Small delay between tests
        await new Promise(resolve => setTimeout(resolve, 500));
      }

      // Summary
      if (results.length > 0) {
        output.innerHTML += `${'='.repeat(80)}\n`;
        output.innerHTML += `üìà SUMMARY (${results.length} documents tested)\n`;
        output.innerHTML += `${'='.repeat(80)}\n\n`;

        const avgTotal = results.reduce((sum, r) => sum + r.timings.total, 0) / results.length;
        const avgSanitize = results.reduce((sum, r) => sum + r.timings.sanitize, 0) / results.length;
        const avgInsert = results.reduce((sum, r) => sum + r.timings.insert, 0) / results.length;

        output.innerHTML += `Average total time:     ${avgTotal.toFixed(0)}ms\n`;
        output.innerHTML += `Average sanitize time:  ${avgSanitize.toFixed(0)}ms\n`;
        output.innerHTML += `Average insert time:    ${avgInsert.toFixed(0)}ms\n\n`;

        // Find slowest
        const slowest = results.reduce((max, r) => r.timings.total > max.timings.total ? r : max);
        output.innerHTML += `Slowest document:       ${slowest.name}\n`;
        output.innerHTML += `                        ${slowest.timings.total.toFixed(0)}ms total\n`;
        output.innerHTML += `                        ${slowest.sizeKB} KB\n\n`;

        // Performance per KB
        output.innerHTML += `Performance per KB:\n`;
        results.forEach(r => {
          const msPerKB = r.timings.total / r.sizeKB;
          output.innerHTML += `   ${r.name.padEnd(40)} ${msPerKB.toFixed(2)}ms/KB\n`;
        });
      }

      button.disabled = false;
      output.innerHTML += `\n‚úÖ Benchmark complete!\n`;
    }
  </script>
</body>
</html>
